package juego;/* * Sirve para generar la malla del terreno, esta se centra en (0,0)en (x,z) y * extiende de TAM_MUNDO/2 sobre estos puntos. */import java.io.*;import java.util.Random;import javax.vecmath.*;import java.text.DecimalFormat;public class Malla {    //el tama�o debe ser potencia de 2    private static final int TAM_MUNDO = 32;    //estas constantes sirven para la altura del terreno en si, con un rango de 10 son monta�as, con un rango de 1 una llanura    private final static double MIN_ALTURA = 1.5;    private final static double MAX_ALTURA = 2;    //guarda los puntos de malla x,y,z    private Point3d malla[][];    //para la salida de la malla    private DecimalFormat df;    private double espesura;    private Random rnd;    public Malla(double flat) {        espesura = flat;        malla = new Point3d[TAM_MUNDO + 1][TAM_MUNDO + 1];        df = new DecimalFormat("0.##");        rnd = new Random(1L);        crearMalla();    }    //crea los 4 puntos que seran las esquinas del terreno    private void crearMalla() {        System.out.println("Creando el terreno");        malla[0][0] =                new Point3d(-TAM_MUNDO / 2, ALturaAleatoria(), -TAM_MUNDO / 2);        malla[0][TAM_MUNDO] =                new Point3d(TAM_MUNDO / 2, ALturaAleatoria(), -TAM_MUNDO / 2);        malla[TAM_MUNDO][0] =                new Point3d(-TAM_MUNDO / 2, ALturaAleatoria(), TAM_MUNDO / 2);        malla[TAM_MUNDO][TAM_MUNDO] =                new Point3d(TAM_MUNDO / 2, ALturaAleatoria(), TAM_MUNDO / 2);        dividirMalla((MAX_ALTURA - MIN_ALTURA) / espesura, TAM_MUNDO / 2);    }    //altura del terreno, explicado arriba en las constantes    private double ALturaAleatoria() {        return (Math.random() * (MAX_ALTURA - MIN_ALTURA) + MIN_ALTURA);    }    //divide la malla del terreno para poder colocar una altura aleatoria con respecto al tamaño    //que se le de del mundo    private void dividirMalla(double dAltura, int pasoTamaño) {        int xPt, zPt;        if (pasoTamaño >= 1) {            zPt = pasoTamaño;            while (zPt < TAM_MUNDO + 1) {                xPt = pasoTamaño;                while (xPt < TAM_MUNDO + 1) {                    malla[zPt][xPt] = getDiamond(zPt, xPt, dAltura, pasoTamaño);                    xPt += (pasoTamaño * 2);                }                zPt += (pasoTamaño * 2);            }            zPt = pasoTamaño;            while (zPt < TAM_MUNDO + 1) {                malla[zPt][0] = dameCuadrado(zPt, 0, dAltura, pasoTamaño);  // left column                xPt = pasoTamaño;                while (xPt < TAM_MUNDO + 1) {                    dameEsquinas(zPt, xPt, dAltura, pasoTamaño);  // back & right cells                    xPt += (pasoTamaño * 2);                }                zPt += (pasoTamaño * 2);            }            xPt = pasoTamaño;            while (xPt < TAM_MUNDO + 1) {                malla[TAM_MUNDO][xPt] =                        dameCuadrado(TAM_MUNDO, xPt, dAltura, pasoTamaño);  // front row                xPt += (pasoTamaño * 2);            }            dividirMalla(dAltura / espesura, pasoTamaño / 2);        }    }    private void dameEsquinas(int z, int x, double dAltura, int pasoTamaño) {        malla[cCoord(z - pasoTamaño)][x] = dameCuadrado(cCoord(z - pasoTamaño), x, dAltura, pasoTamaño);        malla[z][cCoord(x + pasoTamaño)] = dameCuadrado(z, cCoord(x + pasoTamaño), dAltura, pasoTamaño);    }    //posiciona el terreno en el eje x , z    private Point3d getDiamond(int z, int x, double dHeight, int stepSize) {        Point3d izqBack = malla[cCoord(z - stepSize)][cCoord(x - stepSize)];        Point3d derBack = malla[cCoord(z - stepSize)][cCoord(x + stepSize)];        Point3d izqFront = malla[cCoord(z + stepSize)][cCoord(x - stepSize)];        Point3d derFront = malla[cCoord(z + stepSize)][cCoord(x + stepSize)];        double altura = calcAtura(izqBack, derBack, izqFront, derFront, dHeight);        double xMundo = x - (TAM_MUNDO / 2);        double zMundo = z - (TAM_MUNDO / 2);        return new Point3d(xMundo, altura, zMundo);    }    private Point3d dameCuadrado(int z, int x, double dAltura, int pasoTamaño) {        // System.out.println("getSquare: " + z + ", " + x + " /" + stepSize);        Point3d atras = malla[cCoord(z - pasoTamaño)][x];        Point3d frente = malla[cCoord(z + pasoTamaño)][x];        Point3d izq = malla[z][cCoord(x - pasoTamaño)];        Point3d der = malla[z][cCoord(x + pasoTamaño)];        double altura = calcAtura(atras, frente, izq, der, dAltura);        double xMundo = x - (TAM_MUNDO / 2);        double zMundo = z - (TAM_MUNDO / 2);        return new Point3d(xMundo, altura, zMundo);    } // end of getSquare()    private int cCoord(int coordIdx) {        //sirve para modificar las coordenadas y evitar que sean mayores que el mundo o menores que 0        if (coordIdx < 0) {            return TAM_MUNDO + coordIdx;        } else if (coordIdx > TAM_MUNDO) {            return coordIdx - TAM_MUNDO;        } else {            return coordIdx;        }    }    //calcula la altura en cualquier punto dado, si es menor que el minimo da el minimo que puede tener el terreno,    //lo mismo pasa con el mayor    private double calcAtura(Point3d atras, Point3d frente,            Point3d izq, Point3d der, double dAltura) {        double altura = (atras.y + frente.y + izq.y + der.y) / 4.0f                + rangoAleatorio(dAltura);        if (altura < MIN_ALTURA) {            altura = MIN_ALTURA;        } else if (altura > MAX_ALTURA) {            altura = altura % MAX_ALTURA;        }        return altura;    }    //entre -h y h    private double rangoAleatorio(double h) {        return ((Math.random() * 2 * h) - h);        // return ((rnd.nextDouble() * 2 * h) - h);           // evita la aleatoriedad    }    //devuelve la malla como array de vertices    public Point3d[] getVertices() {        int numVerts = TAM_MUNDO * TAM_MUNDO * 4;        Point3d vertices[] = new Point3d[numVerts];        int vPos = 0;        for (int z = 0; z < TAM_MUNDO; z++) {            for (int x = 0; x < TAM_MUNDO; x++) {                vertices[vPos++] = malla[z + 1][x];                vertices[vPos++] = malla[z + 1][x + 1];                vertices[vPos++] = malla[z][x + 1];                vertices[vPos++] = malla[z][x];            }        }        return vertices;    }    //un metodo que imprime en un fichero la malla que se ha producido, solo sirve para poder leer tambien y modificar de ahi    //no usado por el momento, puede que tenga utilidad mas adelante para lo que busco.    public void imprimirMalla(int axis) {        File f = new File("mesh.txt");        PrintWriter pw = null;        try {            pw = new PrintWriter(new FileWriter(f), true);            if (axis == 0) {                pw.println("---------- Coordenadas X ------------");            } else if (axis == 1) {                pw.println("---------- Coordenadas Y ------------");            } else {                pw.println("---------- Coordenadas Z ------------");            }            for (int z = 0; z < TAM_MUNDO + 1; z++) {                for (int x = 0; x < TAM_MUNDO + 1; x++) {                    if (axis == 0) {                        pw.print(df.format(malla[z][x].x) + " ");                    } else if (axis == 1) {                        pw.print(df.format(malla[z][x].y) + " ");                    } else {                        pw.print(df.format(malla[z][x].z) + " ");                    }                }                pw.println();            }            pw.println("--------------------------------------");            System.out.println("Malla.txt");        } catch (Exception e) {            System.out.println("NoSeHaGuardado.txt");        }    }}